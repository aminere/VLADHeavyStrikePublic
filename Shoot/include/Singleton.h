/* 

Amine Rehioui
Created: February 5th 2010

*/

#ifndef _SINGLETON_H_INCLUDED_
#define _SINGLETON_H_INCLUDED_

namespace shoot
{
	//! Template Singleton Class
	template <class T> 
	class Singleton
	{
	public:

		//! Return the unique instance of class T
		inline static T* Instance() 
		{
			if (!m_spInstance)
				DebugBreak();
			SHOOT_ASSERT(m_spInstance, "%s singleton instance not created yet", T::GetSingletonClassName());
			return m_spInstance;
		}

		//! Creates the instance of class T
		static void CreateInstance() 
		{
			SHOOT_ASSERT(!m_spInstance, "%s singleton instance already created", T::GetSingletonClassName());
			m_spInstance = snew T();
		}

		//! Destroys the instance of class T
		static void DestroyInstance() 
		{
			SHOOT_ASSERT(m_spInstance, "%s Singleton instance already destroyed", T::GetSingletonClassName());
			sdelete(m_spInstance);
		}

		//! Overrides an instance
		static void OverrideInstance(T* pOverride)
		{
			if(m_spInstance) 
			{
				DestroyInstance();
			}
			m_spInstance = pOverride; 
		}

		//! returns true if the instance was created
		inline static bool IsCreated() { return m_spInstance != 0; }

	protected:

		static T* m_spInstance;

#define DECLARE_SINGLETON(ClassName) \
	public: \
		ClassName(); \
		virtual ~ClassName(); \
		ClassName(const ClassName&); \
		ClassName& operator = (const ClassName&); \
		static const char* GetSingletonClassName() { return #ClassName; }
	};

	template <class T> T* Singleton<T>::m_spInstance = 0;
}

#endif // _SINGLETON_H_INCLUDED_

